/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CXX {


Author::~Author() noexcept {
}


void Author::__set_name(const std::string& val) {
  this->name = val;
}

void Author::__set_age(const int32_t val) {
  this->age = val;
}
std::ostream& operator<<(std::ostream& out, const Author& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Author::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_age = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->age);
          isset_age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_age)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Author::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Author");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Author &a, Author &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.age, b.age);
}

Author::Author(const Author& other0) {
  name = other0.name;
  age = other0.age;
}
Author& Author::operator=(const Author& other1) {
  name = other1.name;
  age = other1.age;
  return *this;
}
void Author::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Author(";
  out << "name=" << to_string(name);
  out << ", " << "age=" << to_string(age);
  out << ")";
}


Book::~Book() noexcept {
}


void Book::__set_name(const std::string& val) {
  this->name = val;
}

void Book::__set_price(const int32_t val) {
  this->price = val;
}

void Book::__set_author(const Author& val) {
  this->author = val;
}
std::ostream& operator<<(std::ostream& out, const Book& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Book::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_price = false;
  bool isset_author = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->price);
          isset_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->author.read(iprot);
          isset_author = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_price)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_author)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Book::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Book");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("author", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->author.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Book &a, Book &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.price, b.price);
  swap(a.author, b.author);
}

Book::Book(const Book& other2) {
  name = other2.name;
  price = other2.price;
  author = other2.author;
}
Book& Book::operator=(const Book& other3) {
  name = other3.name;
  price = other3.price;
  author = other3.author;
  return *this;
}
void Book::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Book(";
  out << "name=" << to_string(name);
  out << ", " << "price=" << to_string(price);
  out << ", " << "author=" << to_string(author);
  out << ")";
}


Order::~Order() noexcept {
}


void Order::__set_customer_name(const std::string& val) {
  this->customer_name = val;
}

void Order::__set_book_name(const std::string& val) {
  this->book_name = val;
}
std::ostream& operator<<(std::ostream& out, const Order& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Order::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_customer_name = false;
  bool isset_book_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->customer_name);
          isset_customer_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->book_name);
          isset_book_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_customer_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_book_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Order::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Order");

  xfer += oprot->writeFieldBegin("customer_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->customer_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("book_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->book_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Order &a, Order &b) {
  using ::std::swap;
  swap(a.customer_name, b.customer_name);
  swap(a.book_name, b.book_name);
}

Order::Order(const Order& other4) {
  customer_name = other4.customer_name;
  book_name = other4.book_name;
}
Order& Order::operator=(const Order& other5) {
  customer_name = other5.customer_name;
  book_name = other5.book_name;
  return *this;
}
void Order::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Order(";
  out << "customer_name=" << to_string(customer_name);
  out << ", " << "book_name=" << to_string(book_name);
  out << ")";
}


Orders::~Orders() noexcept {
}


void Orders::__set_entry(const std::map<std::string, std::set<std::string> > & val) {
  this->entry = val;
}
std::ostream& operator<<(std::ostream& out, const Orders& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Orders::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_entry = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->entry.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::set<std::string> & _val12 = this->entry[_key11];
              {
                _val12.clear();
                uint32_t _size13;
                ::apache::thrift::protocol::TType _etype16;
                xfer += iprot->readSetBegin(_etype16, _size13);
                uint32_t _i17;
                for (_i17 = 0; _i17 < _size13; ++_i17)
                {
                  std::string _elem18;
                  xfer += iprot->readString(_elem18);
                  _val12.insert(_elem18);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_entry)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Orders::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Orders");

  xfer += oprot->writeFieldBegin("entry", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->entry.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter19;
    for (_iter19 = this->entry.begin(); _iter19 != this->entry.end(); ++_iter19)
    {
      xfer += oprot->writeString(_iter19->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter19->second.size()));
        std::set<std::string> ::const_iterator _iter20;
        for (_iter20 = _iter19->second.begin(); _iter20 != _iter19->second.end(); ++_iter20)
        {
          xfer += oprot->writeString((*_iter20));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Orders &a, Orders &b) {
  using ::std::swap;
  swap(a.entry, b.entry);
}

Orders::Orders(const Orders& other21) {
  entry = other21.entry;
}
Orders& Orders::operator=(const Orders& other22) {
  entry = other22.entry;
  return *this;
}
void Orders::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Orders(";
  out << "entry=" << to_string(entry);
  out << ")";
}

} // namespace
