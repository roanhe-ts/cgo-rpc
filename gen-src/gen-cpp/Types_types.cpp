/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CXX {


Author::~Author() noexcept {
}


void Author::__set_name(const std::string& val) {
  this->name = val;
}

void Author::__set_age(const int32_t val) {
  this->age = val;
}
std::ostream& operator<<(std::ostream& out, const Author& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Author::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_age = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->age);
          isset_age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_age)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Author::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Author");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Author &a, Author &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.age, b.age);
}

Author::Author(const Author& other0) {
  name = other0.name;
  age = other0.age;
}
Author& Author::operator=(const Author& other1) {
  name = other1.name;
  age = other1.age;
  return *this;
}
void Author::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Author(";
  out << "name=" << to_string(name);
  out << ", " << "age=" << to_string(age);
  out << ")";
}


Book::~Book() noexcept {
}


void Book::__set_name(const std::string& val) {
  this->name = val;
}

void Book::__set_price(const int32_t val) {
  this->price = val;
}

void Book::__set_author(const Author& val) {
  this->author = val;
}
std::ostream& operator<<(std::ostream& out, const Book& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Book::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_price = false;
  bool isset_author = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->price);
          isset_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->author.read(iprot);
          isset_author = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_price)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_author)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Book::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Book");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("author", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->author.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Book &a, Book &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.price, b.price);
  swap(a.author, b.author);
}

Book::Book(const Book& other2) {
  name = other2.name;
  price = other2.price;
  author = other2.author;
}
Book& Book::operator=(const Book& other3) {
  name = other3.name;
  price = other3.price;
  author = other3.author;
  return *this;
}
void Book::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Book(";
  out << "name=" << to_string(name);
  out << ", " << "price=" << to_string(price);
  out << ", " << "author=" << to_string(author);
  out << ")";
}


Orders::~Orders() noexcept {
}


void Orders::__set_entry(const std::map<std::string, std::set<std::string> > & val) {
  this->entry = val;
}
std::ostream& operator<<(std::ostream& out, const Orders& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Orders::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_entry = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->entry.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _ktype5;
            ::apache::thrift::protocol::TType _vtype6;
            xfer += iprot->readMapBegin(_ktype5, _vtype6, _size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              std::string _key9;
              xfer += iprot->readString(_key9);
              std::set<std::string> & _val10 = this->entry[_key9];
              {
                _val10.clear();
                uint32_t _size11;
                ::apache::thrift::protocol::TType _etype14;
                xfer += iprot->readSetBegin(_etype14, _size11);
                uint32_t _i15;
                for (_i15 = 0; _i15 < _size11; ++_i15)
                {
                  std::string _elem16;
                  xfer += iprot->readString(_elem16);
                  _val10.insert(_elem16);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_entry)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Orders::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Orders");

  xfer += oprot->writeFieldBegin("entry", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->entry.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter17;
    for (_iter17 = this->entry.begin(); _iter17 != this->entry.end(); ++_iter17)
    {
      xfer += oprot->writeString(_iter17->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter17->second.size()));
        std::set<std::string> ::const_iterator _iter18;
        for (_iter18 = _iter17->second.begin(); _iter18 != _iter17->second.end(); ++_iter18)
        {
          xfer += oprot->writeString((*_iter18));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Orders &a, Orders &b) {
  using ::std::swap;
  swap(a.entry, b.entry);
}

Orders::Orders(const Orders& other19) {
  entry = other19.entry;
}
Orders& Orders::operator=(const Orders& other20) {
  entry = other20.entry;
  return *this;
}
void Orders::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Orders(";
  out << "entry=" << to_string(entry);
  out << ")";
}

} // namespace
